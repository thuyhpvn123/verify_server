<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generate OTP</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
    <script src="javascript.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>


    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }

        input,
        button {
            margin: 10px;
            padding: 10px;
            font-size: 16px;
        }
    </style>
</head>

<body>
    <h2>Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i ƒë·ªÉ nh·∫≠n OTP</h2>
    <input type="text" id="phone" placeholder="Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i" />
    <p><strong>Ch·ªçn ph∆∞∆°ng th·ª©c x√°c th·ª±c:</strong></p>
    <label>
        <input type="checkbox" id="WhatsApp" onclick="toggleCheck('WhatsApp')"> WhatsApp
    </label>
    <label>
        <input type="checkbox" id="Telegram" onclick="toggleCheck('Telegram')"> Telegram
    </label>

    <button onclick="sendToSmartContract()">G·ª≠i OTP l√™n Smart Contract</button>
    <!-- <button onclick="getOTPAndPhoneNumber()">L·∫•y OTP v√† S·ªë ƒëi·ªán tho·∫°i t·ª´ SMC</button>
    <button onclick="getAllDataFromSmartContract()">L·∫•y t·∫•t c·∫£ d·ªØ li·ªáu t·ª´ Smart Contract</button> -->
    <!-- <button onclick="getInfoContract()">Xem D·ªØ Li·ªáu</button> -->
    <button onclick="sendToSmartContractWithoutMetaMask()">Test G·ª≠i OTP Kh√¥ng C·∫ßn MetaMask</button>

    <h3 id="otpDisplay"></h3>
    <p><strong>Public Key (Base64):</strong></p>
    <input type="text" id="publicKeyInput" placeholder="Nh·∫≠p publicKey" />
    <button onclick="getHash()">L·∫•y hash</button>
    <p><strong>Public Key Base64:</strong> <span id="publicKeyDisplay"></span></p>


    <script>
        const TypeMethod = {
            WhatsApp: 0,
            Telegram: 1
        };
        let generatedOTP = "";

        const contractAddress = window.env.contractAddress;// Fix l·ªói render Go template
        const contractABI = window.env.contractABI;
        async function generateOTP() {
            generatedOTP = Math.floor(100000 + Math.random() * 900000).toString(); // T·∫°o OTP 6 ch·ªØ s·ªë
            document.getElementById('otpDisplay').innerText = "OTP c·ªßa b·∫°n l√†: " + generatedOTP;
        }
        let selectedMethod = null;

        function toggleCheck(selectedId) {
            const checkboxes = {
                WhatsApp: document.getElementById('WhatsApp'),
                Telegram: document.getElementById('Telegram')
            };

            // B·ªè ch·ªçn t·∫•t c·∫£ c√°c checkbox
            Object.values(checkboxes).forEach(checkbox => checkbox.checked = false);

            // Ch·ªâ tick v√†o checkbox v·ª´a ƒë∆∞·ª£c click
            checkboxes[selectedId].checked = true;
            selectedMethod = TypeMethod[selectedId.charAt(0).toUpperCase() + selectedId.slice(1)];
            console.log("Selected Method:", selectedMethod);
        }



        async function getInfoContract() {
            if (!window.ethereum) {
                alert("Vui l√≤ng c√†i ƒë·∫∑t MetaMask ƒë·ªÉ ti·∫øp t·ª•c!");
                return;
            }

            const web3 = new Web3(window.ethereum);
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            const contract = new web3.eth.Contract(contractABI, contractAddress);

            const phone = document.getElementById('phone').value;
            if (!phone) {
                alert("Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i ƒë·ªÉ l·∫•y OTP.");
                return;
            }

            try {
                const result = await contract.methods.getOTPInfo(phone).call();
                console.log("Th√¥ng tin OTP:", result);
            } catch (error) {
                console.error("L·ªói khi l·∫•y OTP t·ª´ Smart Contract:", error);
                alert("Kh√¥ng th·ªÉ l·∫•y OTP. Ki·ªÉm tra l·∫°i th√¥ng tin.");
            }
        }

        async function sendToSmartContract() {
            if (!window.ethereum) {
                alert("Vui l√≤ng c√†i ƒë·∫∑t MetaMask ƒë·ªÉ ti·∫øp t·ª•c!");
                return;
            }

            // This part generates the public key, gets the user's account, etc.
            // It remains unchanged.
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: "RSA-OAEP",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: "SHA-256",
                },
                true,
                ["encrypt", "decrypt"]
            );
            const publicKey = await window.crypto.subtle.exportKey("spki", keyPair.publicKey);
            const publicKeyBase64 = btoa(String.fromCharCode(...new Uint8Array(publicKey)));

            const web3 = new Web3(window.ethereum);
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            const accounts = await web3.eth.getAccounts();
            const userAccount = accounts[0];

            const phone = document.getElementById('phone').value;
            if (!phone || selectedMethod === null) {
                alert("Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i v√† ch·ªçn ph∆∞∆°ng th·ª©c x√°c th·ª±c.");
                return;
            }
            const contract = new web3.eth.Contract(contractABI, contractAddress);

            // --- Start of Changed Code ---
            try {
                console.log("Sending transaction to request authentication...");
                const verifyInfo = await contract.methods.requestAuthentication(phone, publicKeyBase64, selectedMethod).send({ from: userAccount });
                console.log("Transaction Receipt:", verifyInfo); // For debugging

                // ‚úÖ CHECK if the event exists before trying to use it
                if (verifyInfo.events && verifyInfo.events.AuthenticationRequested) {
                    const eventData = verifyInfo.events.AuthenticationRequested.returnValues;
                    console.log('event Data:: ', eventData)
                    const otp = eventData.otp;
                    console.log('OTP:: ', otp)
                    const botPhoneNumber = eventData.chatbotPhone;
                    console.log('botPhoneNumber:: ', botPhoneNumber)

                    // Display the information to the user
                    alert(`Your OTP is: ${otp}\nPlease send this to our bot: ${botPhoneNumber}`);

                    // Optional: Redirect to Telegram for a better user experience


                } else {
                    // This runs if the event was not found in the expected place
                    alert("Your OTP request was sent successfully, but we could not retrieve the OTP automatically. Please check your messaging app.");
                    console.error("The 'AuthenticationRequested' event was not found in the transaction receipt.");
                }

            } catch (error) {
                console.error("L·ªói khi g·ª≠i OTP l√™n Smart Contract:", error);
                alert("G·ª≠i OTP th·∫•t b·∫°i. Vui l√≤ng ki·ªÉm tra console log v√† th·ª≠ l·∫°i.");
            }
            // --- End of Changed Code ---
        }

        // without metamask
        async function sendToSmartContractWithoutMetaMask() {
            if (typeof Web3 === "undefined") {
                alert("Web3 ch∆∞a ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ki·ªÉm tra l·∫°i!");
                return;
            }

            const web3 = new Web3("wss://bsc-testnet-rpc.publicnode.com");
            const privateKey = "712d07d2f0a4435d44063f8c6a52286a9c00e28bd340400951fbd35c3fa5621d";
            const account = web3.eth.accounts.privateKeyToAccount(privateKey);

            web3.eth.accounts.wallet.add(account);
            web3.eth.defaultAccount = account.address;

            const contract = new web3.eth.Contract(contractABI, contractAddress);

            const phone = document.getElementById('phone').value.replace(/^[+@]/, '');
            console.log(phone);

            if (!phone) {
                alert("Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i tr∆∞·ªõc khi g·ª≠i.");
                return;
            }

            try {
                console.log("G·ª≠i giao d·ªãch addBot...");
                const addBotData = await contract.methods.checkAvailableBot(selectedMethod).call();
                console.log(addBotData)
                //**************************************************************************************************************************************************
                const keyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "RSA-OAEP",
                        modulusLength: 2048, // ƒê·ªô d√†i kh√≥a
                        publicExponent: new Uint8Array([1, 0, 1]), // Gi√° tr·ªã m·∫∑c ƒë·ªãnh cho RSA
                        hash: "SHA-256",
                    },
                    true, // Kh√≥a c√≥ th·ªÉ xu·∫•t ra hay kh√¥ng
                    ["encrypt", "decrypt"]
                );

                // Xu·∫•t kh√≥a c√¥ng khai
                const publicKey = await window.crypto.subtle.exportKey("spki", keyPair.publicKey);
                const publicKeyBase64 = btoa(String.fromCharCode(...new Uint8Array(publicKey)));
                document.getElementById("publicKeyDisplay").textContent = publicKeyBase64;

                console.log("G·ª≠i giao d·ªãch requestAuthentication...");


                const requestAuthData = contract.methods.requestAuthentication(phone, publicKeyBase64, selectedMethod, addBotData).encodeABI();
                const txRequestAuth = {
                    to: contractAddress,
                    data: requestAuthData,
                    gas: 2000000,
                    gasPrice: await web3.eth.getGasPrice(),
                    from: account.address
                };

                const signedTxRequestAuth = await web3.eth.accounts.signTransaction(txRequestAuth, privateKey);
                const receiptRequestAuth = await web3.eth.sendSignedTransaction(signedTxRequestAuth.rawTransaction);
                console.log("Giao d·ªãch requestAuthentication th√†nh c√¥ng:", receiptRequestAuth.transactionHash);
                const eventABI = [
                    { type: "address", indexed: true, name: "user" },
                    { type: "uint256", indexed: false, name: "otp" },
                    { type: "string", indexed: false, name: "chatbotPhone" }, // Correct name
                    { type: "uint8", indexed: false, name: "typeMethod" }  // S·ªë ƒëi·ªán tho·∫°i bot
                ];

                // L·∫•y log s·ª± ki·ªán t·ª´ receipt
                const log = receiptRequestAuth.logs[0];

                // Gi·∫£i m√£ d·ªØ li·ªáu t·ª´ log
                const decodedEvent = web3.eth.abi.decodeLog(eventABI, log.data, log.topics.slice(1));

                alert(`OTP c·ªßa b·∫°n l√†: ${decodedEvent.otp}`);
                // üîπ **L·∫•y OTP t·ª´ s·ª± ki·ªán `AuthenticationRequested`**
                const botUsername = addBotData.replace(/^\@/, '');
                console.log(botUsername)
                window.location.href = `https://t.me/${botUsername}`;

            } catch (error) {
                console.error("L·ªói khi g·ª≠i giao d·ªãch:", error);
                alert("C√≥ l·ªói x·∫£y ra, vui l√≤ng ki·ªÉm tra console log.");
            }

        }
        async function getHash() {
            if (!window.ethereum) {
                alert("Vui l√≤ng c√†i ƒë·∫∑t MetaMask ƒë·ªÉ ti·∫øp t·ª•c!");
                return;
            }

            const web3 = new Web3(window.ethereum);
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            const contract = new web3.eth.Contract(contractABI, contractAddress);

            const publicKey = document.getElementById('publicKeyInput').value;
            if (!publicKey) {
                alert("Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i ƒë·ªÉ l·∫•y OTP.");
                return;
            }

            try {
                const result = await contract.methods.getPublicKeyHash(publicKey).call();
                console.log("Th√¥ng tin hash:", result);
            } catch (error) {
                console.error("L·ªói khi l·∫•y OTP t·ª´ Smart Contract:", error);
                alert("Kh√¥ng th·ªÉ l·∫•y OTP. Ki·ªÉm tra l·∫°i th√¥ng tin.");
            }
        }
    </script>
</body>

</html>